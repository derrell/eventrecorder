{
  "version": 3,
  "sources": [
    "/home/travis/build/cboulanger/eventrecorder/source/class/cboulanger/eventrecorder/player/Abstract.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "include",
    "cboulanger",
    "eventrecorder",
    "MState",
    "MHelperMethods",
    "statics",
    "utilityFunctions",
    "waitForCondition",
    "fn",
    "interval",
    "timeout",
    "timeoutMsg",
    "Promise",
    "resolve",
    "reject",
    "intervalId",
    "setInterval",
    "clearInterval",
    "setTimeout",
    "Error",
    "waitForEvent",
    "qxObjOrId",
    "type",
    "expectedData",
    "qxObj",
    "lang",
    "Type",
    "isString",
    "Id",
    "getQxObject",
    "getTimeout",
    "timeoutId",
    "removeListener",
    "changeEventHandler",
    "e",
    "app",
    "Init",
    "getApplication",
    "eventdata",
    "event",
    "Data",
    "getData",
    "undefined",
    "warn",
    "addListenerOnce",
    "isArray",
    "length",
    "entries",
    "index",
    "expectedItem",
    "JSON",
    "stringify",
    "isRegExp",
    "match",
    "toString",
    "info",
    "clearTimeout",
    "properties",
    "mode",
    "check",
    "init",
    "apply",
    "useDefaultDelay",
    "nullable",
    "maxDelay",
    "canReplayInBrowser",
    "canExportExecutableCode",
    "macros",
    "events",
    "construct",
    "__commands",
    "_globalRef",
    "window",
    "resetMacros",
    "name",
    "members",
    "__macro_stack",
    "__macro_stack_index",
    "__vars",
    "__promises",
    "__lastId",
    "__lastCmd",
    "getLastId",
    "getLastCommand",
    "_applyMode",
    "value",
    "old",
    "_addCommands",
    "commands",
    "concat",
    "sort",
    "a",
    "b",
    "getCommands",
    "getMacros",
    "dispose",
    "data",
    "marshal",
    "Json",
    "createModel",
    "names",
    "definitions",
    "descriptions",
    "setMacros",
    "macroExists",
    "getNames",
    "indexOf",
    "getMacroNames",
    "getMacroDefinition",
    "getDefinitions",
    "getItem",
    "getMacroDescription",
    "getDescriptions",
    "addMacro",
    "description",
    "push",
    "beginMacroDefintion",
    "isInMacroDefinition",
    "getCurrentMacroName",
    "leaveMacroDefinition",
    "_tokenize",
    "line",
    "Assert",
    "assertString",
    "tokens",
    "token",
    "prevChar",
    "insideQuotes",
    "trim",
    "split",
    "char",
    "parse",
    "_translateLine",
    "startsWith",
    "addComment",
    "substr",
    "command",
    "args",
    "toLocaleLowerCase",
    "method_name",
    "replace",
    "translatedLine",
    "isInAwaitBlock",
    "_addPromiseToAwaitStack",
    "_handleMeta",
    "script",
    "expandVariables",
    "lines",
    "var_def",
    "_getMacro",
    "macro_name",
    "macro_lines",
    "i",
    "map",
    "l",
    "RegExp",
    "_defineVariables",
    "getOwnPropertyNames",
    "key",
    "_translateVariables",
    "var_name",
    "var_content",
    "_generateUtilityFunctionsCode",
    "filter",
    "Boolean",
    "join",
    "_play",
    "steps",
    "step",
    "getRunning",
    "debug",
    "fireDataEvent",
    "getMode",
    "code",
    "repeat",
    "result",
    "eval",
    "replay",
    "setRunning",
    "await_block",
    "dialog",
    "Dialog",
    "error",
    "message",
    "Timer",
    "once",
    "cmd_hide_info",
    "translate",
    "_translate",
    "translatedLines",
    "new_lines",
    "translation",
    "generateWaitForConditionCode",
    "condition",
    "timeoutmsg",
    "getInterval",
    "generateWaitForEventCode",
    "id",
    "generateWaitForEventTimoutFunction",
    "comment",
    "escapeRegexpChars",
    "s",
    "createRegexpForJsonComparison",
    "searchExp",
    "foundRegExps",
    "m",
    "slice",
    "promiseCode",
    "getExportFileExtension",
    "cmd_assert_uri",
    "uri",
    "cmd_assert_match_uri",
    "uri_regexp",
    "cmd_config_set_mode",
    "cmd_define",
    "macro_description",
    "cmd_end",
    "cmd_await_all",
    "player",
    "Abstract"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n  UI Event Recorder\n\n  Copyright:\n    2018 Christian Boulanger\n\n  License:\n    MIT license\n    See the LICENSE file in the project's top-level directory for details.\n\n  Authors: Christian Boulanger\n\n************************************************************************ */\n\n/**\n * The base class of all player types\n * @require(qx.bom.Element)\n */\nqx.Class.define(\"cboulanger.eventrecorder.player.Abstract\", {\n  extend : qx.core.Object,\n  include : [\n    cboulanger.eventrecorder.MState,\n    cboulanger.eventrecorder.MHelperMethods\n  ],\n\n  statics: {\n    utilityFunctions : {\n      /**\n       * Runs the given function in the interval until it returns true or the\n       * given timeout is reached. Returns a promise that will resolve once the\n       * function returns true or rejects if the timeout is reached.\n       * @param fn {Function} Condition function\n       * @param interval {Number} The interval in which to run the function. Defaults to 100 ms.\n       * @param timeout {Number} The timeout in milliseconds. Defaults to 10 seconds\n       * @param timeoutMsg {String|undefined} An optional addition to the timeout error message\n       * @return {Promise}\n       */\n      waitForCondition: function(fn, interval=100, timeout=10000, timeoutMsg) {\n        return new Promise(((resolve, reject) => {\n          let intervalId = setInterval(() => {\n            if (fn()) {\n              clearInterval(intervalId);\n              resolve();\n            }\n          }, interval);\n          setTimeout(() => {\n            clearInterval(intervalId);\n            reject(new Error(timeoutMsg || `Timeout waiting for condition.`));\n          }, timeout);\n        }));\n      },\n\n      /**\n       * Returns a promise that will resolve (with any potential event data) if\n       * the given object fires an event with the given type and will reject if\n       * the timeout is reached before that happens.\n       *\n       * @param qxObjOrId {qx.core.Object|String} If string, assume it is the object id\n       * @param type {String} Type of the event\n       * @param expectedData {*|undefined} The data to expect. If undefined,\n       * resolve. If a regular expression, the event data as a JSON literal will\n       * be matched with that regex and the promise will resolve when it matches.\n       * Otherwise, the data will be compared with the actual event data both\n       * serialized to JSON.\n       * @param timeout {Number|undefined} The timeout in milliseconds. Defaults to 10 seconds\n       * @param timeoutMsg {String|undefined} An optional addition to the timeout error message\n       * @return {Promise}\n       */\n      waitForEvent: function(qxObjOrId, type, expectedData, timeout, timeoutMsg) {\n        let qxObj = qxObjOrId;\n        if (qx.lang.Type.isString(qxObjOrId)) {\n          qxObj = qx.core.Id.getQxObject(qxObjOrId);\n          if (!qxObj) {\n            throw new Error(`Invalid object id ${qxObjOrId}`);\n          }\n        }\n        timeout = timeout || this.getTimeout();\n\n        return new Promise(((resolve, reject) => {\n          // create a timeout\n          let timeoutId = setTimeout(() => {\n            qxObj.removeListener(type, changeEventHandler);\n            reject(new Error(timeoutMsg || `Timeout waiting for event \"${type}.`));\n          }, timeout);\n\n          // function to create a listener for the change event\n          let changeEventHandler = e => {\n            let app = qx.core.Init.getApplication();\n            let eventdata = e instanceof qx.event.type.Data ? e.getData() : undefined;\n            if (expectedData !== undefined) {\n              if (eventdata === undefined) {\n                app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, received 'undefined'`);\n                qxObj.addListenerOnce(type, changeEventHandler);\n                return;\n              }\n              if (qx.lang.Type.isArray(expectedData) && qx.lang.Type.isArray(eventdata) && expectedData.length && expectedData[0] instanceof qx.core.Object) {\n                /** a) either match array and check for \"live\" qooxdoo objects in the array (this is for selections), */\n                for (let [index, expectedItem] of expectedData.entries()) {\n                  if (expectedItem !== eventdata[index]) {\n                    app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, received non-matching array of qooxdoo objects!`);\n                    qxObj.addListenerOnce(type, changeEventHandler);\n                    return;\n                  }\n                }\n              } else {\n                // convert event data to JSON\n                try {\n                  eventdata = JSON.stringify(e.getData());\n                } catch (e) {\n                  throw new Error(`\\n--- When waiting for event '${type}' on object ${qxObj}, could not stringify event data for comparison.`);\n                }\n                if (qx.lang.Type.isRegExp(expectedData)) {\n                  /** b) or match a regular expression, */\n                  if (!eventdata.match(expectedData)) {\n                    app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, expected data to match '${expectedData.toString()}', got ${eventdata}!`);\n                    qxObj.addListenerOnce(type, changeEventHandler);\n                    return;\n                  }\n                } else {\n                  /* c) or compare JSON equality */\n                  try {\n                    expectedData = JSON.stringify(expectedData);\n                  } catch (e) {\n                    throw new Error(`When waiting for event '${type}' on object ${qxObj}, could not stringify expected data for comparison.`);\n                  }\n                  if (eventdata !== expectedData) {\n                    app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, expected '${JSON.stringify(expectedData)}', got '${JSON.stringify(eventdata)}'!\"`);\n                    qxObj.addListenerOnce(type, changeEventHandler);\n                    return;\n                  }\n                }\n              }\n            }\n            app.info(`\\n+++ Received correct event '${type}' on object ${qxObj}.\"`);\n            clearTimeout(timeoutId);\n            resolve(eventdata);\n          };\n\n          // add a listener\n          qxObj.addListenerOnce(type, changeEventHandler);\n        }));\n      }\n    }\n  },\n\n  properties: {\n    /**\n     * The replay mode. Possible values:\n     * \"test\": The script is executed ignoring the \"delay\" commands, errors will\n     * stop execution and will be thrown.\n     * \"presentation\": The script is executed with user delays, errors will be\n     * logged to the console but will not stop execution\n     */\n    mode: {\n      check: [\"test\", \"presentation\"],\n      event: \"changeMode\",\n      init: \"presentation\",\n      apply: \"_applyMode\"\n    },\n\n    /**\n     * The timeout in milliseconds\n     */\n    timeout: {\n      check: \"Number\",\n      init: 10000\n    },\n\n    /**\n     * The interval between checks if waiting for a condition to fulfil\n     */\n    interval: {\n      check: \"Number\",\n      init: 100\n    },\n\n    /**\n     * if true, ignore user delays and use defaultDelay\n     */\n    useDefaultDelay: {\n      check: \"Boolean\",\n      nullable: false,\n      init: false\n    },\n\n    /**\n     * The maximun delay between events (limits user-generated delay)\n     */\n    maxDelay: {\n      check: \"Number\",\n      init: 1000\n    },\n\n    /**\n     * Whether the player can replay the generated script in the browser\n     */\n    canReplayInBrowser: {\n      check: \"Boolean\",\n      nullable: false,\n      init: false,\n      event: \"changeCanReplay\"\n    },\n\n    /**\n     * Whether the player can export code that can be used outside this application\n     */\n    canExportExecutableCode: {\n      check: \"Boolean\",\n      nullable: false,\n      init: false,\n      event: \"changeCanExportExecutableCode\"\n    },\n\n    /**\n     * Macro data\n     */\n    macros: {\n      check: \"qx.core.Object\",\n      init: null,\n      event: \"changeMacros\"\n    }\n  },\n\n  events: {\n    /**\n     * Fired with each step of the replayed script. The event data is an array\n     * containing the number of the step and the number of steps\n     */\n    \"progress\" : \"qx.event.type.Data\"\n  },\n\n  /**\n   * constructor\n   */\n  construct: function() {\n    this.base(arguments);\n    this.__commands = [];\n    this._globalRef = \"eventrecorder_player\";\n    window[this._globalRef] = this;\n    this.resetMacros();\n    // inject utility functions in the statics section into the global scope\n    // so that they are available in eval()\n    for (let [name, fn] of Object.entries(this.self(arguments).utilityFunctions)) {\n      window[name] = fn;\n    }\n  },\n\n  /**\n   * The methods and simple properties of this class\n   */\n  members :\n  {\n    /**\n     * A globally accessible reference to the player implementation\n     */\n    _globalRef: null,\n\n    /**\n     * A list of available commands\n     */\n    __commands: null,\n\n    /**\n     * An array of object containing information on the macros that are currently\n     * being defined (in a nested way)\n     * @var {Object[]}\n     */\n    __macro_stack: null,\n\n    /**\n     * The index of the macro in the macro stack that is currently defined\n     * @var {Integer}\n     */\n    __macro_stack_index: -1,\n\n    /**\n     * Variables\n     */\n    __vars: null,\n\n    /**\n     * An array of promises which are to be awaited\n     */\n    __promises: null,\n\n    /**\n     * Last id addressed\n     */\n    __lastId : null,\n\n    /**\n     * Last command used\n     */\n    __lastCmd : null,\n\n    /**\n     * Return the last id used\n     * @return {String|null}\n     */\n    getLastId() {\n      return this.__lastId;\n    },\n\n    /**\n     * Return the last command used\n     * @return {String|null}\n     */\n    getLastCommand() {\n      return this.__lastCmd;\n    },\n\n    /**\n     * Stub to be overridden if needed\n     * @param value\n     * @param old\n     * @private\n     */\n    _applyMode(value, old) {},\n\n    /**\n     * NOT IMPLEMENTED\n     * Adds the given array of commands\n     * @param commands {Object[]}\n     */\n    _addCommands(commands) {\n      this.__commands = this.__commands.concat(commands).sort((a, b) => a.name > b.name);\n    },\n\n    /**\n     * NOT IMPLEMENTED\n     * Returns the list of availabe commands\n     * @return {Object[]}\n     */\n    getCommands() {\n      return this.__commands;\n    },\n\n    /**\n     * Clears all macro definitions and the macro stack\n     */\n    resetMacros() {\n      if (this.getMacros()) {\n        this.getMacros().dispose();\n      }\n      this.__macro_stack = [];\n      this.__macro_stack_index = -1;\n      let macros = qx.data.marshal.Json.createModel({\n        names: [],\n        definitions: [],\n        descriptions: []\n      }, true);\n      this.setMacros(macros);\n    },\n\n    /**\n     * Returns true if a macro of that name exists.\n     * @param {String} name\n     * @return {boolean}\n     */\n    macroExists(name) {\n      return this.getMacros().getNames().indexOf(name) >= 0;\n    },\n\n    /**\n     * Returns the names of the currently defined macros as a qx.data.Array\n     * @return {qx.data.Array}\n     */\n    getMacroNames() {\n      return this.getMacros().getNames();\n    },\n\n    /**\n     * Returns an array with the lines of the macro of that name\n     * @param {String} name\n     * @return {Array}\n     */\n    getMacroDefinition(name) {\n      let index = this.getMacros().getNames().indexOf(name);\n      if (index < 0) {\n        throw new Error(`Macro '${name}' does not exist`);\n      }\n      return this.getMacros().getDefinitions().getItem(index);\n    },\n\n    /**\n     * Returns the description of the macro\n     * @param {String} name\n     * @return {String}\n     */\n    getMacroDescription(name) {\n      let index = this.getMacros().getNames().indexOf(name);\n      if (index < 0) {\n        throw new Error(`Macro '${name}' does not exist`);\n      }\n      return this.getMacros().getDescriptions().getItem(index);\n    },\n\n    /**\n     * Adds an empty macro of this name\n     * @param {String} name\n     * @param {String|undefined} description\n     */\n    addMacro(name, description) {\n      if (this.macroExists(name)) {\n        throw new Error(`A macro of the name '${name}' alread exists.`);\n      }\n      let macros = this.getMacros();\n      macros.getDefinitions().push([]);\n      macros.getDescriptions().push(description||\"\");\n      macros.getNames().push(name);\n    },\n\n    /**\n     * Begins the definition of a macro of that name.\n     * @param {String} name\n     */\n    beginMacroDefintion(name) {\n      let index = ++this.__macro_stack_index;\n      this.__macro_stack[index] = { name };\n    },\n\n    /**\n     * Returns true if the player is currently in a macro definition\n     * @return {boolean}\n     */\n    isInMacroDefinition() {\n      return this.__macro_stack_index >= 0;\n    },\n\n    /**\n     * Return the name of the macro that is currently being defined\n     * @return {String}\n     */\n    getCurrentMacroName() {\n      if (!this.isInMacroDefinition()) {\n        throw new Error(\"No macro is currently defined\");\n      }\n      let {name} = this.__macro_stack[this.__macro_stack_index];\n      return name;\n    },\n\n    /**\n     * Leave the current macro, i.e. return to the including script/macro\n     */\n    leaveMacroDefinition() {\n      this.getCurrentMacroName(); // this will throw if none is being defined\n      this.__macro_stack_index--;\n    },\n\n    /**\n     * Simple tokenizer which splits expressions separated by whitespace, but keeps\n     * expressions in quotes (which can contain whitespace) together. Parses tokens\n     * as JSON expressions, but accepts unquoted text as strings.\n     * @param line {String}\n     * @return {String[]}\n     * @private\n     */\n    _tokenize(line) {\n      qx.core.Assert.assertString(line);\n      let tokens = [];\n      let token = \"\";\n      let prevChar=\"\";\n      let insideQuotes = false;\n      for (let char of line.trim().split(\"\")) {\n        switch (char) {\n          case \"\\\"\":\n            insideQuotes=!insideQuotes;\n            token += char;\n            break;\n          case \" \":\n            // add whitespace to token if inside quotes\n            if (insideQuotes) {\n              token += char;\n              break;\n            }\n            // when outside quotes, whitespace is end of token\n            if (prevChar !== \" \") {\n              // parse token as json expression or as a string if that fails\n              try {\n                token = JSON.parse(token);\n              } catch (e) {}\n              tokens.push(token);\n              token = \"\";\n            }\n            break;\n          default:\n            token += char;\n        }\n        prevChar = char;\n      }\n      if (token.length) {\n        try {\n          token = JSON.parse(token);\n        } catch (e) {}\n        tokens.push(token);\n      }\n      return tokens;\n    },\n\n    /**\n     * Translates a single line from the intermediate code into the target\n     * language. To be overridden by subclasses if neccessary.\n     *\n     * @param line {String}\n     * @return {String}\n     * @ignore(command)\n     * @ignore(args)\n     */\n    _translateLine(line) {\n      // comment\n      if (line.startsWith(\"#\")) {\n        return this.addComment(line.substr(1).trim());\n      }\n      // parse command line\n      let [command, ...args] = this._tokenize(line);\n      command = command.toLocaleLowerCase();\n      this.__lastCmd = command;\n      this.__lastId = args[0]; // assume first argument is id\n      // run command generation implementation\n      let method_name = \"cmd_\" + command.replace(/-/g, \"_\");\n      if (typeof this[method_name] == \"function\") {\n        let translatedLine = this[method_name].apply(this, args);\n        if (translatedLine && translatedLine.startsWith(\"(\") && this.isInAwaitBlock()) {\n          this._addPromiseToAwaitStack(translatedLine);\n          return null;\n        }\n        return translatedLine;\n      }\n      throw new Error(`Unsupported/unrecognized command: '${command}'`);\n    },\n\n    /**\n     * Given a script, return an array of lines with all variable and macro\n     * declarations registered and removed. Optionally, variables are expanded.\n     *\n     * @param script {String}\n     * @param expandVariables {Boolean} Whether to expand the found variables. Default to true\n     * @return {Array}\n     * @private\n     */\n    _handleMeta(script, expandVariables=true) {\n      this.resetMacros();\n      this.__vars = {};\n      let lines = [];\n      for (let line of script.split(/\\n/)) {\n        line = line.trim();\n        if (!line) {\n          continue;\n        }\n        // expand variables\n        let var_def = line.match(/([^=\\s]+)\\s*=\\s*(.+)/);\n        if (var_def) {\n          this.__vars[var_def[1]] = var_def[2];\n          continue;\n        } else if (expandVariables && line.match(/\\$([^\\s\\d\\/]+)/)) {\n          line = line.replace(/\\$([^\\s\\d\\/]+)/g, (...args) => this.__vars[args[1]]);\n        }\n\n        // register macros\n        if (line.startsWith(\"define \")) {\n          if (this.isInAwaitBlock()) {\n            throw new Error(\"You cannot use a macro in an await block.\");\n          }\n          this._translateLine(line);\n          continue;\n        }\n\n        // await block\n        if (line.startsWith(\"await-\")) {\n          this._translateLine(line);\n        }\n\n        // end await block or macro\n        if (line === \"end\") {\n          // macro\n          if (!this.isInAwaitBlock()) {\n            this._translateLine(line);\n            continue;\n          }\n          // await block\n          this._translateLine(line);\n        }\n\n        // add code to macro\n        if (this.isInMacroDefinition()) {\n          let name = this.getCurrentMacroName();\n          this.getMacroDefinition(name).push(line);\n          continue;\n        }\n\n\n        lines.push(line);\n      }\n      // remove variable registration if they have been expanded\n      if (expandVariables) {\n        this.__vars = {};\n      }\n      return lines;\n    },\n\n    /**\n     * Returns the lines for the macro of the given name, with the given arguments\n     * replaced (1st arg -> $1, 2nd arg -> $2, etc.). If it doesn't exist,\n     * return undefined.\n     * @param macro_name {String} The name of the macro\n     * @param args {Array} An array of arguments to be replaced in the macro code\n     * @return {Array|undefined}\n     * @private\n     */\n    _getMacro(macro_name, args) {\n      if (!this.macroExists(macro_name)) {\n        return undefined;\n      }\n      let macro_lines = this.getMacroDefinition(macro_name);\n      // argument placeholders\n      for (let i = 0; i < args.length; i++) {\n        macro_lines = macro_lines.map(l => l.replace(new RegExp(\"\\\\$\" + (i + 1), \"g\"), JSON.stringify(args[i])));\n      }\n      return macro_lines;\n    },\n\n\n    /**\n     * Returns an array of lines containing variable declarations\n     * @return {string[]}\n     * @private\n     */\n    _defineVariables() {\n      return Object.getOwnPropertyNames(this.__vars)\n        .map(key => `const ${key} =\"${this.__vars[key]}\";`);\n    },\n\n    /**\n     * Translates variables in a line\n     * @param line {String}\n     * @private\n     * @return {String}\n     * @ignore(args)\n     */\n    _translateVariables(line) {\n      if (line.match(/\\$([^\\s\\d\\/]+)/)) {\n        line = line.replace(/\\$([^\\s\\d\\/]+)/g, (...args) => {\n          let var_name = args[1];\n          let var_content = this.__vars[var_name];\n          if (var_content === undefined) {\n            throw new Error(`Variable '${var_name}' has not been defined.`);\n          }\n          return var_content;\n        });\n      }\n      return line;\n    },\n\n    /**\n     * Returns the code of utility functions needed for the command implementations.\n     * @param script {String} Optional script code to be searched for the function name.\n     * If given, omit function if not present in the script code\n     * @return {string[]}\n     * @private\n     * @ignore(fn)\n     */\n    _generateUtilityFunctionsCode(script) {\n      return Object.entries(this.self(arguments).utilityFunctions)\n        .filter(([name]) => script ? script.match(new RegExp(name)) : true)\n        .map(([name, fn]) => fn.toString()\n          .replace(/function \\(/, `function ${name}(`)\n          // remove comments, see https://stackoverflow.com/questions/5989315/regex-for-match-replacing-javascript-comments-both-multiline-and-inline\n          .replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, \"$1\")\n          .split(/\\n/)\n          .map(line => line.trim())\n          .filter(line => Boolean(line))\n          .join(\"\")\n        );\n    },\n\n    /**\n     * Replays a number of script lines\n     * @param lines {String[]}\n     * @param steps {Integer?}\n     * @param step {Integer?}\n     * @return {Promise<boolean>}\n     * @private\n     */\n    async _play(lines, steps=0, step=0) {\n      for (let line of lines) {\n        // stop if we're not running (user pressed \"stop\" button\n        if (!this.getRunning()) {\n          return false;\n        }\n\n        // ignore comments\n        if (line.startsWith(\"#\")) {\n          continue;\n        }\n\n        // variables\n        line = this._translateVariables(line);\n\n        // play macros recursively\n        let [command, ...args] = this._tokenize(line);\n        let macro_lines = this._getMacro(command, args);\n        if (macro_lines !== undefined) {\n          if (steps) {\n            step++;\n            this.debug(`\\n===== Step ${step} / ${steps}, executing macro ${command} =====`);\n          }\n          await this._play(macro_lines);\n          continue;\n        }\n\n        // count steps if given, wait doesn't count as a step\n        if (steps && !line.startsWith(\"wait\") && !line.startsWith(\"delay\")) {\n          step++;\n          // inform listeners\n          this.fireDataEvent(\"progress\", [step, steps]);\n          this.debug(`\\n===== Step ${step} / ${steps} ====`);\n        }\n        // ignore delay in test mode\n        if (this.getMode()===\"test\" && line.startsWith(\"delay\")) {\n          continue;\n        }\n\n        // translate\n        let code = this._translateLine(line);\n        // skip empty lines\n        if (!code) {\n          continue;\n        }\n        this.debug(`${line}\\n${\"-\".repeat(40)}\\n${code}`);\n        // execute\n        let result = window.eval(code);\n        if (result instanceof Promise) {\n          try {\n            await result;\n          } catch (e) {\n            throw e;\n          }\n        }\n      }\n      return true;\n    },\n\n    /**\n     * Replays the given script of intermediate code\n     * @param script {String} The script to replay\n     * @return {Promise} Promise which resolves when the script has been replayed, or\n     * rejects with an error\n     * @todo implement pausing\n     */\n    async replay(script) {\n      this.setRunning(true);\n      let lines = this._handleMeta(script);\n      let steps = 0;\n      let await_block= false;\n      for (let line of lines) {\n        if (line.startsWith(\"await-\")) {\n          await_block = true;\n          continue;\n        }\n        if (line.startsWith(\"end\")) {\n          await_block = false;\n          continue;\n        }\n        if (!await_block && !line.startsWith(\"wait \") && !line.startsWith(\"#\") && !line.startsWith(\"delay\")) {\n          steps++;\n        }\n      }\n\n      // replay it!\n      try {\n        await this._play(lines, steps, 0);\n      } catch (e) {\n        switch (this.getMode()) {\n          case \"test\":\n            throw e;\n          case \"presentation\":\n            this.warn(e);\n            dialog.Dialog.error(e.message);\n        }\n      }\n      this.setRunning(false);\n      qx.event.Timer.once(()=> this.cmd_hide_info(), null, 100);\n    },\n\n    /**\n     * Translates the intermediate code into the target language\n     * @param script\n     * @return {string} executable code\n     */\n    translate(script) {\n      return this._translate(script);\n    },\n\n    /**\n     * Implementation for #translate()\n     * @param script\n     * @return {string}\n     * @private\n     */\n    _translate(script) {\n      let lines = this._handleMeta(script);\n      let translatedLines = this._defineVariables();\n      for (let line of lines) {\n        line = line.trim();\n        let [command, ...args] = this._tokenize(line);\n        let macro_lines = this._getMacro(command, args);\n        let new_lines = (macro_lines || [line])\n          .map(l => this._translateLine(l))\n          .filter(l => Boolean(l));\n        translatedLines = translatedLines.concat(new_lines);\n      }\n      let translation = translatedLines.join(\"\\n\");\n      return this._generateUtilityFunctionsCode(translation)\n        .concat(translatedLines)\n        .join(\"\\n\");\n    },\n\n    /**\n     * Given an async piece of code which checks for a condition or an application state,\n     * return code that checks for this condition, throwing an error if the\n     * condition hasn't been fulfilled within the set timeout.\n     * @param condition {String} The condition expression as a string\n     * @param timeoutmsg {String|undefined} An optional message to be shown if the condition hasn't been met before the timeout.\n     */\n    generateWaitForConditionCode(condition, timeoutmsg) {\n      qx.core.Assert.assertString(condition);\n      timeoutmsg = timeoutmsg || `Timeout waiting for condition '${condition}' to fulfil.\"`;\n      return `(waitForCondition(() => ${condition}, ${this.getInterval()}, ${this.getTimeout()}, \"${timeoutmsg}\"))`;\n    },\n\n    /**\n     * Generates code that returns a promise which will resolve (with any potential event data) if the given object fires\n     * an event with the given type and data (if applicable) and will reject if the timeout is reached before that happens.\n     * @param id {String} The id of the object to monitor\n     * @param type {String} The type of the event to wait for\n     * @param data {*|undefined} The data to expect. Must be serializable to JSON. Exception: if the data is a string that\n     * starts with \"{verbatim}\", the unquoted string is used\n     * @param timeoutmsg {String|undefined} An optional message to be shown if the event hasn't been fired before the timeout.\n     * @return {String}\n     */\n    generateWaitForEventCode(id, type, data, timeoutmsg) {\n      qx.core.Assert.assertString(id);\n      qx.core.Assert.assertString(type);\n      if (qx.lang.Type.isString(data) && data.startsWith(\"{verbatim}\")) {\n        data = data.substr(10);\n      } else {\n        data = JSON.stringify(data);\n      }\n      if (!timeoutmsg) {\n        timeoutmsg=`Timeout waiting for event '${type}' on '${id}'`;\n      }\n\n      return `(waitForEvent(\"${id}\", \"${type}\",${data}, ${this.getTimeout()}, \"${timeoutmsg}\"))`;\n    },\n\n    /**\n     * Generates code that returns a promise which will resolve (with any\n     * potential event data) if the given object fires an event with the given\n     * type and data (if applicable). After the timeout, it will execute the\n     * given code and restart the timeout.\n     *\n     * @param id {String} The id of the object to monitor\n     * @param type {String} The type of the event to wait for\n     * @param data {*|null} The data to expect. Must be serializable to JSON. In case\n     * of events that do not have data, you MUST explicitly pass 'undefined' as\n     * argument if you use the following arguments\n     * @param code {String} The code to execute after the timeout\n     * @return {String}\n     */\n    generateWaitForEventTimoutFunction(id, type, data, code) {\n      qx.core.Assert.assertString(id);\n      qx.core.Assert.assertString(type);\n      return `(new Promise(async (resolve, reject) => { \n        while (true){\n          try {\n            await waitForEvent(qx.core.Id.getQxObject(\"${id}\"), \"${type}\", ${data===undefined?\"undefined\":JSON.stringify(data)}, ${this.getTimeout()});\n            return resolve(); \n          } catch (e) {\n            console.debug(e.message);\n            ${code};\n          }\n        }\n      }))`.split(/\\n/).map(l => l.trim()).join(\"\");\n    },\n\n    /**\n     * Adds a line comment to the target script\n     * @param comment {String}\n     * @return {string}\n     */\n    addComment(comment) {\n      return \"// \" + comment;\n    },\n\n    /**\n     * Escapes all characters in a string that are special characters in a regular expression\n     * @param s {String} The string to escape\n     * @return {String}\n     */\n    escapeRegexpChars(s) {\n      return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n    },\n\n    /**\n     * Creates a regular expression that matches a json string. In this string, you can use a regular expression\n     * enclosed by \"<!\" and \"!>\" to replace data that cannot be known in advance, such as tokens or session ids.\n     * Example: '{token:\"<![A-Za-z0-9]{32}!>\",user:\"admin\">' will match '{\"token\":\"OnBHqQd59VHZYcphVADPhX74q0Sc6ERR\",\"user\":\"admin\"}'\n     * @param s {string}\n     */\n    createRegexpForJsonComparison(s) {\n      let searchExp = /<![^<][^!]+!>/g;\n      let foundRegExps = s.match(searchExp);\n      if (foundRegExps && foundRegExps.length) {\n        let index=0;\n        // remove escape sequence\n        foundRegExps = foundRegExps.map(m => m.slice(2, -2));\n        // replace placeholders\n        return this.escapeRegexpChars(s).replace(searchExp, () => foundRegExps[index++]);\n      }\n      return this.escapeRegexpChars(s);\n    },\n\n    /**\n     * Adds promise code to a list of promises that need to resolve before the\n     * script proceeds\n     * @param promiseCode\n     */\n    _addPromiseToAwaitStack(promiseCode) {\n      if (!qx.lang.Type.isArray(this.__promises)) {\n        throw new Error(\"Cannot add promise since no await block has been opened.\");\n      }\n      this.__promises.push(promiseCode);\n    },\n\n    /**\n     * Returns the file extension of the downloaded file in the target language\n     * @return {string}\n     */\n    getExportFileExtension() {\n      throw new Error(\"Method getExportFileExtension must be impemented in subclass\");\n    },\n\n    /**\n     * Whether the player is in an await block\n     * @return {Boolean}\n     */\n    isInAwaitBlock() {\n      return qx.lang.Type.isArray(this.__promises);\n    },\n\n    /*\n    ============================================================================\n       COMMANDS\n    ============================================================================\n    */\n\n    /**\n     * Asserts that the current url matches the given value (RegExp)\n     * @param uri {String}\n     */\n    cmd_assert_uri(uri) {\n      return `qx.core.Assert.assertEquals(window.location.href, \"${uri}\", \"Script is valid on '${uri}' only'\")`;\n    },\n\n    /**\n     * Asserts that the current url matches the given value (RegExp)\n     * @param uri_regexp {String} A string containing a regular expression\n     */\n    cmd_assert_match_uri(uri_regexp) {\n      if (this.getMode()===\"presentation\") {\n        return `if(!window.location.href.match(new RegExp(\"${uri_regexp}\"))){alert(\"The eventrecorder script is meant to be played on a website that matches '${uri_regexp}'.\");window[\"${this._globalRef}\"].stop();}`;\n      }\n      return `qx.core.Assert.assertMatch(window.location.href, \"${uri_regexp}\", \"Current URL does not match '${uri_regexp}'\")`;\n    },\n\n    /**\n     * Sets the player mode\n     * @param mode\n     * @return {string}\n     */\n    cmd_config_set_mode(mode) {\n      return `window[\"${this._globalRef}\"].setMode(\"${mode}\");`;\n    },\n\n    /**\n     * Starts the definition of a macro\n     * @param {String} macro_name\n     * @param {String|undefined} macro_description\n     * @return {null}\n     */\n    cmd_define(macro_name, macro_description) {\n      if (this.macroExists(macro_name)) {\n        throw new Error(`Cannot define macro '${macro_name}' since a macro of that name already exists.`);\n      }\n      this.addMacro(macro_name, macro_description);\n      this.beginMacroDefintion(macro_name);\n      return null;\n    },\n\n    /**\n     * Ends the definition of a macro or a block of awaitable statements\n     * @return {null}\n     */\n    cmd_end() {\n      if (this.__promises) {\n        let line = this.__promises.length ? `(Promise.all([${this.__promises.join(\",\")}]))` : null;\n        this.__promises = null;\n        return line;\n      }\n      if (this.__macro_stack_index < 0) {\n        throw new Error(`Unexpected 'end'.`);\n      }\n      this.leaveMacroDefinition();\n      return null;\n    },\n\n    /**\n     * Starts a block of statements that return promises. The player will wait for\n     * all of the promises to resolve before proceeding.\n     */\n    cmd_await_all() {\n      this.__promises=[];\n      return null;\n    }\n  }\n});\n"
  ]
}